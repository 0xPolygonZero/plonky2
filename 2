#[cfg(not(feature = "std"))]
use alloc::vec;
#[cfg(not(feature = "std"))]
use alloc::vec::Vec;

use itertools::Itertools;
use plonky2_field::extension::FieldExtension;
use plonky2_field::types::Field;
use plonky2_maybe_rayon::*;

use crate::field::extension::{flatten, unflatten, Extendable};
use crate::field::polynomial::{PolynomialCoeffs, PolynomialValues};
use crate::fri::oracle::PolynomialBatch;
use crate::fri::proof::{FriInitialTreeProof, FriProof, FriQueryRound, FriQueryStep};
use crate::fri::structure::{FriBatchInfo, FriInstanceInfo};
use crate::fri::{FriConfig, FriParams};
use crate::hash::hash_types::{RichField, NUM_HASH_OUT_ELTS};
use crate::hash::hashing::PlonkyPermutation;
use crate::hash::merkle_proofs::MerkleProof;
use crate::hash::merkle_tree::MerkleTree;
use crate::iop::challenger::Challenger;
use crate::plonk::config::GenericConfig;
use crate::plonk::plonk_common::reduce_with_powers;
use crate::timed;
use crate::util::reducing::ReducingFactor;
use crate::util::reverse_index_bits_in_place;
use crate::util::timing::TimingTree;




// use serde::{Deserialize, Serialize};
use crate::plonk::config::Hasher;
use crate::hash::merkle_tree::MerkleCap;


const QN: usize = 20;

#[derive(Debug)]
pub struct Acc<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    pub merkle_cap: MerkleCap<F, H>,
    pub lde_polynomial_coeffs: PolynomialCoeffs<F::Extension>,
    pub lde_polynomial_values: PolynomialValues<F::Extension>,
    pub ood_point: F::Extension,
    pub ood_eval: F::Extension, 
    pub domain_points: Vec<F>,
    pub domain_evals: Vec<F::Extension>,
    pub proof: AccPf<F, H, D>,
}

impl<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize>
    Acc<F, H, D>
{
    pub fn is_dummy() -> bool {
        true
    }
}


#[derive(Debug)]
pub struct AccPf<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    pub merkle_cap: MerkleCap<F, H>,
    pub ood_point: F::Extension,
    pub ood_eval: F::Extension, 
    pub domain_points: Vec<F>,
    pub domain_evals: Vec<F::Extension>,
    pub proofs: Vec<BoilQueryProof<F, H, D>>,
}

#[derive(Debug)]
pub struct BoilQueryProof<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    pub evals_proofs: Vec<(Vec<F>, MerkleProof<F, H>)>,
    pub pacc_evals: Vec<F::Extension>,
    pub pacc_merkle_proof: MerkleProof<F, H>,
}

pub fn prove_accumulation<F: RichField + Extendable<D>, C: GenericConfig<D, F = F>, const D: usize>(
    prev: Option<Acc<F, C::Hasher, D>>,
    instance: &FriInstanceInfo<F, D>,
    oracles: &[&PolynomialBatch<F,C,D>],
    challenger: &mut Challenger<F, C::Hasher>,
    fri_params: &FriParams,
    final_poly_coeff_len: Option<usize>,
    max_num_query_steps: Option<usize>,
    timing: &mut TimingTree,
)  -> Acc<F, C::Hasher, D> {
    let alpha = challenger.get_extension_challenge::<D>();
    let mut alpha = ReducingFactor::new(alpha);

    println!("***\nHI fro prove_accumulation!\n***\n");

    let mut final_poly = PolynomialCoeffs::empty();

    for FriBatchInfo { point, polynomials } in &instance.batches {
        let polys_coeff = polynomials.iter().map(|fri_poly| {
            &oracles[fri_poly.oracle_index].polynomials[fri_poly.polynomial_index]
        });
        let composition_poly = timed!(
            timing,
            &format!("reduce batch of {} polynomials", polynomials.len()),
            alpha.reduce_polys_base(polys_coeff)
        );
        let mut quotient = composition_poly.divide_by_linear(*point);
        quotient.coeffs.push(F::Extension::ZERO); // pad back to power of two
        alpha.shift_poly(&mut final_poly);
        final_poly += quotient;
    }

    if let Some(prev_acc) = prev {
        assert!(prev_acc.domain_points.len() == QN);
        let mut polys_coeff = (0..QN).into_iter().map(|i| {
            prev_acc.lde_polynomial_coeffs
                .divide_by_linear(F::Extension::from_basefield(prev_acc.domain_points[i]))
        })
        .collect_vec();
        polys_coeff.push(
            prev_acc.lde_polynomial_coeffs
                .divide_by_linear(prev_acc.ood_point)
        );
        let mut quotient = alpha.reduce_polys2(polys_coeff);
        alpha.shift_poly(&mut final_poly);
        final_poly += quotient;
    }

    let lde_final_poly = final_poly.lde(fri_params.config.rate_bits);
    let mut lde_final_values = timed!(
        timing,
        &format!("perform final FFT {}", lde_final_poly.len()),
        lde_final_poly.coset_fft(F::coset_shift().into())
    );

    reverse_index_bits_in_place(&mut lde_final_values.values);
    let leaves = lde_final_values.values
        .iter()
        .map(|&x| x.to_basefield_array().to_vec() )
        .collect();
    let tree = MerkleTree::<F, C::Hasher>::new(leaves, fri_params.config.cap_height);

    challenger.observe_cap(&tree.cap);

    let ood_point = challenger.get_extension_challenge::<D>();

    let ood_eval = lde_final_poly.eval(ood_point);

    let mut domain_points  = Vec::new();
    let mut domain_evals = Vec::new();
    for _ in 0..QN {
        let zi = challenger.get_challenge();
        domain_points.push(zi);
        let ev = lde_final_poly.eval(F::Extension::from_basefield(zi));
        domain_evals.push(ev);
    }

    let n = lde_final_values.len();
    let proofs = challenger
        .get_n_challenges(QN)
        .into_par_iter()
        .map(|rand| {
            let x_index = rand.to_canonical_u64() as usize % n;
            let evals_proofs = oracles 
                .iter()
                .map(|&t| (t.merkle_tree.get(x_index).to_vec(), t.merkle_tree.prove(x_index)))
                .collect::<Vec<_>>();
            let pacc_evals = unflatten(tree.get(x_index));
            let pacc_merkle_proof = tree.prove(x_index);
            BoilQueryProof {
                evals_proofs,
                pacc_evals,
                pacc_merkle_proof,
            }
        })
        .collect::<Vec<BoilQueryProof<F, C::Hasher, D>>>();


    let res = Acc {
        merkle_cap: tree.cap.clone(),
        lde_polynomial_coeffs: lde_final_poly,
        lde_polynomial_values: lde_final_values,
        ood_point,
        ood_eval, 
        domain_points: domain_points.clone(),
        domain_evals: domain_evals.clone(),
        proof: AccPf {
            merkle_cap: tree.cap,
            ood_point,
            ood_eval, 
            domain_points,
            domain_evals,
            proofs,
        },
    };

    res
}


