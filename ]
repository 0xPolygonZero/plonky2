#[cfg(not(feature = "std"))]
use alloc::vec;

use itertools::Itertools;
use plonky2_maybe_rayon::*;
use crate::timed;
use crate::util::{
    timing::TimingTree,
    reducing::ReducingFactor, 
    reverse_bits, 
    reverse_index_bits_in_place, 
    log2_strict
};

use crate::field::{
    extension::{unflatten, Extendable, FieldExtension}, 
    polynomial::PolynomialCoeffs, 
    types::Field
};
use crate::hash::{
    hash_types::RichField, 
    merkle_proofs::MerkleProof,
    merkle_tree::{MerkleCap, MerkleTree},
};
use crate::iop::challenger::Challenger;
use crate::plonk::config::{GenericConfig, Hasher};
use crate::fri::{oracle::PolynomialBatch, proof::FriChallenges};
use crate::fri::{structure::{FriBatchInfo, FriInstanceInfo}, FriParams};
use crate::boil::QN;


#[derive(Debug)]
pub struct Acc<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    // Merklte Tree which represents acc's polynomial
    pub merkle_tree: MerkleTree<F, H>,
    // coefficient representation of acc's polynomial, only first 1/rate_bits lements are not-zero 
    pub polynomial_coeffs: PolynomialCoeffs<F::Extension>,
    // out-of-domain random point
    pub ood_point: F::Extension,
    // evaluation at ood point
    pub ood_eval: F::Extension, 
    // QN of in-domain random points
    pub ind_points: Vec<F>,
    // evaluations at each of the in-domain random points
    pub ind_evals: Vec<F::Extension>,
}

#[derive(Debug)]
pub struct AccInfo<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    // Cap of acc's Merkle Tree 
    pub merkle_cap: MerkleCap<F, H>,
    // - - - 
    pub ood_point: F::Extension,
    pub ood_eval: F::Extension, 
    pub ind_points: Vec<F>,
    pub ind_evals: Vec<F::Extension>,
}

#[derive(Debug)]
pub struct AccProof<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    // Merkle cap for a new acc poly
    pub merkle_cap: MerkleCap<F, H>,
    // claimed eval of a new acc poly for ood random point
    pub ood_eval: F::Extension,
    // claimed evals of a new acc poly for each the QN in-domain random points
    pub ind_evals: Vec<F::Extension>,
    // proof for each of the QN in-domain random points
    pub qproofs: Vec<BoilQueryProof<F, H, D>>,
}

#[derive(Debug)]
pub struct BoilQueryProof<F: RichField + Extendable<D>, H: Hasher<F>, const D: usize> {
    // Merkle proofs for evaluations of FRI batches (4 of them)
    pub base_evals_proofs: Vec<(Vec<F>, MerkleProof<F, H>)>,
    // Merkle proofs for evaluations of input accumulators
    pub ext_evals_proofs: Vec<(Vec<F::Extension>, MerkleProof<F, H>)>,
}

pub fn prove_accumulation<F, C, const D: usize>(
    accs: &[&Acc<F, C::Hasher, D>],
    fri_instance: &FriInstanceInfo<F, D>,
    fri_oracles: &[&PolynomialBatch<F,C,D>],
    fri_params: &FriParams,
    challenger: &mut Challenger<F, C::Hasher>,
    timing: &mut TimingTree,
) -> (Acc<F, C::Hasher, D>, AccProof<F, C::Hasher, D>, FriChallenges<F, D>) 
where
    F: RichField + Extendable<D>,
    C: GenericConfig<D, F = F>,
{
    let alpha = challenger.get_extension_challenge::<D>();
    let myalpha = alpha.clone();
    let mut alpha = ReducingFactor::new(alpha);

    println!("***\nChechpoint:: fn::prove_accumulation!\n***");

    let mut final_poly = PolynomialCoeffs::empty();

    println!("=== {}", fri_params.degree_bits);
    for FriBatchInfo { point, polynomials } in &fri_instance.batches {
        let polys_coeff = polynomials.iter().map(|fri_poly| {
            &fri_oracles[fri_poly.oracle_index].polynomials[fri_poly.polynomial_index]
        });
        let composition_poly = timed!(
            timing,
            &format!("reduce batch of {} polynomials", polynomials.len()),
            alpha.reduce_polys_base(polys_coeff)
        );
        let mut quotient = composition_poly.divide_by_linear(*point);
        quotient.coeffs.push(F::Extension::ZERO); // pad back to power of two
        alpha.shift_poly(&mut final_poly);
        final_poly += quotient;
    }
    println!("{}", final_poly.coeffs.len());

    for acc in accs {
        println!("     NEXT ACC");
        assert!(acc.ind_points.len() == QN);
        let mut polys_coeff = (0..QN).into_iter().map(|i| {
                let mut cur = acc.polynomial_coeffs
                    .divide_by_linear(F::Extension::from_basefield(acc.ind_points[i]));
                cur.coeffs.push(F::Extension::ZERO);
                cur
            })
            .collect_vec();
        let mut quotient = acc.polynomial_coeffs.divide_by_linear(acc.ood_point);
        quotient.coeffs.push(F::Extension::ZERO);
        polys_coeff.push(quotient);
        let lc_poly = alpha.reduce_polys2(polys_coeff);
        alpha.shift_poly(&mut final_poly);
        final_poly += lc_poly;
    }
    println!("{}", final_poly.coeffs.len());

    let lde_final_poly = final_poly.lde(fri_params.config.rate_bits);
    let mut lde_final_values = timed!(
        timing,
        &format!("perform final FFT {}", lde_final_poly.len()),
        lde_final_poly.coset_fft(F::coset_shift().into())
    );

    reverse_index_bits_in_place(&mut lde_final_values.values);
    let n = lde_final_values.len();
    let leaves = lde_final_values.values
        .iter()
        .map(|&x| x.to_basefield_array().to_vec() )
        .collect();
    let tree = MerkleTree::<F, C::Hasher>::new(leaves, fri_params.config.cap_height);

    challenger.observe_cap(&tree.cap);

    // Query phase
    let ood_point = challenger.get_extension_challenge::<D>();
    let ood_eval = lde_final_poly.eval(ood_point);
    let ind_points  = challenger.get_n_challenges(QN).into_iter().collect_vec();
    let ind_evals = ind_points
        .iter()
        .map(|rand| {
            let x_index = rand.to_canonical_u64() as usize % n;
            let log_n = log2_strict(n);
            let subgroup_x = F::MULTIPLICATIVE_GROUP_GENERATOR
                * F::primitive_root_of_unity(log_n).exp_u64(reverse_bits(x_index, log_n) as u64);
            let ev = final_poly.eval(
                F::Extension::from_basefield(subgroup_x)
            );
            ev
        })
        .collect::<Vec<F::Extension>>();

    println!("Before queries");
    let qproofs = ind_points
        .par_iter()
        .map(|rand| {
            let x_index = rand.to_canonical_u64() as usize % n;
            println!("{} == {}", x_index, n);
            let base_evals_proofs = fri_oracles 
                .iter()
                .map(|&t| (t.merkle_tree.get(x_index).to_vec(), t.merkle_tree.prove(x_index)))
                .collect::<Vec<_>>();
            let ext_evals_proofs = accs
                .iter()
                .map(|&t| (unflatten(t.merkle_tree.get(x_index)), t.merkle_tree.prove(x_index)))
                .collect::<Vec<_>>();
            BoilQueryProof {
                base_evals_proofs,
                ext_evals_proofs,
            }
        })
        .collect::<Vec<BoilQueryProof<F, C::Hasher, D>>>();
   
    println!("degree = {}, lde_deg = {}", fri_params.degree_bits, fri_params.lde_bits());
    println!("#oracles = {}", fri_oracles.len());
    fri_oracles.iter().for_each(|x| {
        println!("    polys in oracle: {}", x.polynomials.len());
    });
    println!("#batches = {}", fri_instance.batches.len());
    fri_instance.batches.iter().for_each(|x| {
        println!("    point: {}, polys in batch: {}", x.point, x.polynomials.len());
    });
    println!("#accs = {}", accs.len());

    let ccap = tree.cap.clone();
    let new_acc = Acc {
        merkle_tree: tree,
        polynomial_coeffs: lde_final_poly,
        ood_point,
        ood_eval, 
        ind_points: ind_points.clone(),
        ind_evals: ind_evals.clone(),
    };
    let acc_proof = AccProof {
        merkle_cap: ccap,
        ood_eval, 
        ind_evals: ind_evals.clone(),
        qproofs,
    };


    let indic = ind_points
        .iter()
        .map(|rand| {
            let x_index = rand.to_canonical_u64() as usize % lde_final_values.len();
            x_index
        })
        .collect::<Vec<usize>>();
    let sss: FriChallenges<F, D> = FriChallenges {
        fri_alpha: myalpha,
        fri_betas: Vec::new(),
        fri_pow_response: F::ZERO,
        fri_query_indices: indic, 
    };


    (new_acc, acc_proof, sss)
}

